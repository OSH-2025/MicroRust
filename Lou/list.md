### Rust 改写 Minix 操作系统
#### 背景
Minix 是于 1987 年开发的类 UNIX 教学操作系统，旨在通过简洁的微内核架构（约 12,000 行代码）帮助学生理解操作系统核心原理。然而，其原生实现存在内存安全和并发管理隐患，且部分模块（如内存管理和进程通信）的可靠性受限于传统编程模式。

#### 目标
通过 Rust 的现代特性重构 Minix 操作系统，提升其内存安全性和可维护性。

深入理解 `unsafe` 代码的使用边界、中断处理和内存映射 I/O。
学习为自定义目标配置 Rust 工具链，使用 QEMU 进行内核调试。
对比原版与 Rust 版的系统性能，评估零成本抽象的实际开销。

#### 内容
研究 Minix 3 的微内核设计，重点关注内存管理、进程管理和进程间通信模块，识别现有 C 代码中易出现内存错误的模块。
用 Rust 所有权机制重构物理内存分配器，设计基于区域的内存管理策略。
利用 Rust 的 `Arc<Mutex<T>>` 或无锁并发模型，重构消息传递机制，避免数据竞争。
通过 Rust 的 FFI 与 Minix 的 C 代码交互，逐步替换原有模块。
在 QEMU 模拟器上测试改写后的内核模块，并对比性能指标和安全性。

### Rust 改写 Mach 的内存管理模块

#### 背景
Mach 是经典的微内核操作系统，其内存管理模块（如虚拟内存映射 `vm_map` 和内核内存分配器 `kalloc`）采用 C 语言实现。由于 C 语言缺乏内存安全保证，长期存在潜在的内存错误风险（如越界访问、释放后使用），且现有算法对多核并发的支持有限。

#### 目标
使用 Rust 重构 Mach 的内存管理模块，利用 Rust 语言的特性，在保持微内核高性能的同时，提升内存安全性并优化多核效率。

#### 内容
分析 Mach 现有内存管理机制，识别现有实现中的内存安全风险点。
设计 Rust 内存管理模块。
构建混合编译流程，将 Rust 模块嵌入 Mach 的构建系统。
在 QEMU 虚拟化的 Mach 环境中测试内存管理功能（如进程地址空间创建、大页内存分配），对 `unsafe` 代码进行未定义行为检测。

### Rust 改写 Zircon（Fuchsia OS）驱动/用户态服务

#### 背景
Zircon 是 Fuchsia OS 的微内核，负责管理硬件资源、进程调度和系统安全。当前 Zircon 的驱动和用户态服务主要基于 C/C++ 实现。Rust 语言凭借所有权机制、零成本抽象和强类型系统，可显著提升内存安全和并发安全性，适合改造 Zircon 的关键模块。

#### 目标
使用 Rust 改写 Zircon 的 设备驱动框架（DDK） 或 核心用户态服务（如文件系统或网络协议栈），实现以下目标：
- 通过 Rust 的内存安全特性消除潜在漏洞。
- 保留与现有 C/C++ 组件的兼容性。
- 验证性能与资源效率是否优于原实现。

#### 内容
分析现有实现，研究 Zircon 驱动模型（如 zx_device_t 生命周期管理），分析用户态服务与内核的 IPC 机制（如 Channel 通信）。
用 Rust 重写目标模块（例如 USB 驱动或 vfs 文件系统服务），利用 async/await 简化异步逻辑。
使用 Fuchsia 的测试框架（如 zx_test）验证功能正确性，对比原版与 Rust 版的内存占用、吞吐量及延迟。