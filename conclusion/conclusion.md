# 结题报告

## 目录

[结题报告](#结题报告)
- [结题报告](#结题报告)
  - [目录](#目录)
  - [项目介绍](#项目介绍)
  - [小组成员以及分工](#小组成员以及分工)
  - [立项依据](#立项依据)
  - [项目设计](#项目设计)
    - [系统架构](#系统架构)
      - [IPFS分布式存储模块](#ipfs分布式存储模块)
      - [Neo4j图数据库模块](#neo4j图数据库模块)
      - [大语言模型内容模块](#大语言模型内容模块)
      - [Web前端](#web前端)
  - [效果展示](#效果展示)
  - [最终项目与中期设计对比](#最终项目与中期设计对比)
  - [项目总结](#项目总结)
  - [致谢](#致谢)

## 项目介绍

本项目名为 `MicroRust`，是一个支持多种文件类型和搜索模式的的分布式图文件系统，本项目在24年项目VIVO50FS和ArkFS的基础上，构建了一个智能分布式图文件存储系统，并为用户提供了简洁直观的Web服务接口，支持文件的上传、检索与下载。系统由三大核心模块组成：基于IPFS实现的分布式存储模块，用于安全高效地保存文件；Neo4j图数据库模块，用于管理文件间的结构化关系；以及结合大语言模型的内容解析模块，负责对文件进行语义理解与标签生成。系统首先利用大语言模型对文件内容进行语义分析，提取关键词与标签，随后借助Neo4j构建文件间的关联网络，提升检索效率与信息组织能力，最后使用IPFS高效、安全地分布式储存文件。整体方案融合了大语言模型与图文件结构的优势，提供了一种面向大语言模型时代的智能分布式图文件系统服务的实现方案。

## 小组成员以及分工

- 叶梓文: IPFS模块，各个模块间的整合。
- 陈聆祎: Neo4j模块。
- 黄袁宇轩: 大语言模型模块。
- 刘雅兰: 协助完成大语言模块。
- 许傲施: 网页前端设计。
- 娄彦轩: 前期资料查找。

上述分工仅体现了每位小组成员在项目中的主要职责。在实际开发过程中，项目的各个方面都凝聚了每位成员的共同努力与协作，成果是团队协同配合的共同结晶。

## 立项依据

### 往年小组项目情况


#### MyGlow 小组：

- 重新搭建了整个分布式框架，并解决了数据一致性问题，提高了系统的鲁棒性。重写了前端和可视化，实现了更好的用户体验。
- 此外，通过更新ray打标的大模型，他们提高了图文件系统的准确性和效率。

#### Arkfs 小组：
- 利用大语言模型提取文本中的关键信息，形成特征向量传递给任务调度层，通过执行对应操作，实现文件系统的自动化增，删，改，查操作。

#### vivo50 小组：
- 分布式处理中央服务器并实现反向代理，从而优化负载均衡问题，并且使用多模态大模型生成向量化索引，更好地支持多种文件格式，使得搜索结果更加准确。

#### 本组创新方向：
- 使用ipfs分布式文件系统作为文件存储载体。
- 采用deepseek和讯飞星火作为大模型打标，可以处理图片和文档的输入形式。
- Html和flask库的前端构建。


## 项目设计
### 系统架构
#### IPFS分布式存储模块
##### IPFS的实现原理
- 内容寻址：
IPFS中的每一个文件通过其内容的加密哈希值进行唯一标识。
- 数据分块：
IPFS会把文件切分为固定大小的数据块，分布式地存储、检索、验证其完整性。
- 一致性：
IPFS不以强一致性为目标，而是设计为最终一致性系统，更偏向于内容的持久性与可验证性，而非更新的同步性。这是IPFS系统相比于VIVO50的JuiceFS的最大优势。
##### IPFS的部署
###### 下载
IPFS服务依赖于本地的IPFS可执行文件，在使用我们的Web服务之前，需要在本地部署IPFS服务。
为了简化部署工作，我们将其封装为了一个install程序，适配Windows和Linux平台，安装完成后可直接使用ipfs命令。
###### 节点初始化
为了使用IPFS节点支持Web应用，需要使用ipfs命令完成对IPFS节点的初始化，我们将其封装为start_ipfs和connect_ipfs函数。
- start_ipfs： 初始化IPFS仓库并启动IPFS节点
- connect_ipfs：获取IPFS节点的multiaddress在用户结束Web应用时，需要使用ipfs命令关闭IPFS节点，我们同样将其封装为terminate_ipfs函数。
- terminate_ipfs：关闭IPFS节点我们将上述函数整合进入了Web应用的启动和关闭过程，用户只需与Web应用交互。
###### 连接
- 选定任一系统的IPFS节点作为中枢节点，记录该节点所在系统的ip地址，并告知其它所有分布式系统；
- 首先启动中枢节点的IPFS节点，获取节点的multiaddress；
- 随后启动其他IPFS节点并记录multiaddress，使用http协议与中枢节点交换彼此的multiaddress ，通过IPFS接口互相连接；
- 节点之间不直接连接，只通过中枢节点进行消息转发。
- 在测试时，我们采用了多台虚拟机模拟分布式系统。我们将主机的IPFS节点设置为中枢节点，将虚拟机的IPFS节点与主机的IPFS节点相连。
- ![pic1](https://github.com/user-attachments/assets/d59d444a-e733-4e9f-aa70-e3b7452ad21b)

###### 基础操作
- download_file_from_ipfs：从IPFS下载文件到临时变量并返回
- upload_file_to_ipfs：上传文件到IPFS并返回CID，上传
- get_file_content_from_ipfs：从IPFS获取文本文件内容
###### 扩展
- 动态地选择IPFS节点的连接网络中的动态节点，例如，每次选择最先启动的IPFS节点作为中枢节点。
- 改进IPFS节点网络的拓扑结构，以支持在部分IPFS节点异常失效时保持网络的完整性，例如，将星型拓扑改进为Fat-Tree结构。
- 9图片
#### Neo4j图数据库模块
###### 图数据库介绍
图数据库是一种通过图结构进行数据存储和查询的数据库，数据库中包含节点、边和属性等信息。Neo4j 图数据库使用 Cypher 语言（类似数据库模式的语言）进行修改和查询，具有高效性。
###### 数据库的部署
- 我们使用云服务器部署了 Neo4j 数据库的云端服务，并通过 python API 支持客户端发送增加，删除和查询文件信息的请求，同时使用 neo4j browser 可以实时监控图数据库的使用情况和文件信息。
- ![pc2](https://github.com/user-attachments/assets/85f2b9e1-beac-4a8e-8854-4da88aaeba0c)

###### 信息交互
- 在我们的项目中，图数据库需要存储的是文件和标签的基本信息，以及关联信息。因此我们延用了 OSH2024 vivo50 小组的设计，以文件和标签为点，以关联关系为边构建图文件系统。
- ![pc3](https://github.com/user-attachments/assets/67ed3daf-af22-4139-9b87-9da52c045f67)

###### 模糊匹配和扩展
- 在实际应用中，用户通常会给出多个标签，查询符合条件的文件，这些标签很可能不完整，也可能有错误的标签。
  在这种情况下，我们使用模糊匹配进行处理。在匹配所有标签失败时，我们考虑每个至少匹配一个标签的文件，
  将这些文件按照匹配标签的数量从大到小排序，然后保留匹配数量最大的 3 或 5 个文件，发送给前端让用户选择具体操作哪个文件。
- 可以在tag的基础上进行简单的虚拟文件夹设计，从而实现更高效的存储。
- 我们的图文件系统使用的是最基础的模式匹配，可以为不同节点标签设置匹配度权值，从而计算相似度，再设置相应的阈值选取。
#### 大语言模型内容模块
###### 功能介绍
引入大模型根据输入文件内容生成对应tag，可接受图片和文本文件的文件类型。
###### 大模型部署的选择和优缺点分析
1.大模型部署在本地：采用大模型本地部署显卡资源要求高，但是在资源充足时速度快且稳定，安全性强，如果在大型项目资金充足时建议使用。
2.远程api链接，通过网络传输信息显卡要求低，在资源不够充足时延迟时间与本地部署速度基本一致，安全性较低，但是成本较低。
针对我们实验的具体情况，我们对于二者进行了探索并决定使用api链接方式。
- 我们采用了deepseek和讯飞星火大模型作为我们的打标ai
1. 文本：我们将其转为UTF-8或GBK编码后进行标签提取
2. docx：我们通过已有的docx库提取docx文本内容后进行标签提取
3. 图片：我们现将其转为base64码，再进行标签的提取
4. pdf: 由于目前大模型多模态的技术仍是有限的，我们的pdf提取仍限于文字阶段，所以我们先用哦OCRai将其转为文字
5. 其他文件: 对于其他具有复杂编码格式的文件，我们目前只能对其文件名进行打标我们生成的标签仍然只能限于若干个有限的标签
###### 打标图例
- ![p5](https://github.com/user-attachments/assets/58202dcb-dd87-47a5-8093-50eb5891e7c5)

- ![p6](https://github.com/user-attachments/assets/76a983ee-ca08-4ee0-9b67-09ac633f10bb)

###### 处理用户命令问题的优化
- 我们不再采取用户命令的解析，而是直接采用按钮的方式进入不同界面，再由用户输入相应的信息，依据信息进行文件处理，这样用户不会再因为用户命令传输而延迟等待，实测大约需要4-8s等待时间
- 这一方面来说，我们相对ArkFS组实现了速度的提升，我们的不同的文件的处理路径更加直接，不必要所有的用户命令都需要进行api的时间传输延迟
#### Web前端
##### 前端的不同实现方式和优缺点分析
1. grdio库：依赖 Python 后端，初始加载较慢， 受限于预制组件，同时后端代码暴露，但是轻量级，设计师能力不受限，少量代码即可实现，方便我们用于测试
- 代码兼容性不好，要插入其他组件如按钮，显示板困难，上传文件无法拖拽，UI固定且较为简单，传输信息，且无法轻易对于前端外观进行修改，时序修改困难
- ![p7](https://github.com/user-attachments/assets/2d15f49e-b91e-4ada-8685-9b2144773785)

2. Html和flask库: 安全性好，灵活性更强，可无缝集成，纯前端运行，不会透露敏感数据，但对开发者要求较高
- 功能明显增多，外观修改兼容性强，并且支持页面跳转，我们不再针对用户命令进行解析，而是由用户选择进行精准的操作，同时可以对于用户文件打标进行预览.

![p8](https://github.com/user-attachments/assets/189c5157-0759-46de-9279-ad09bfe3d232)

3.实际实现过程
先运用gradio库搭建初步可以使用的前端，并完成基础的上传文件与用户命令解析，后端IPFS，Neo4j的使用测试随后使用html对于基础功能进行扩展
在实际过程中，我们最终决定去掉前端用户命令解析，而是用户自己选择操作：鉴于删除等操作的敏感性
##### 前端优化方向
增加自然语言命令解析，如：语音输入、文字命令要求
2. 增加前端支持的文件操作，如：直接修改已上传的文件
3. 加入上传文件的本地缓存与云盘缓存功能
4. 加入用户秘钥，增强安全性5. 将Web应用部署在公网，投入实际应用
## 效果展示
![p8](https://github.com/user-attachments/assets/89baf914-16f5-43f4-8610-69c32d119858)

![p9](https://github.com/user-attachments/assets/de7e4f59-6daa-4613-b6f0-814b00f3144d)

## 最终项目与中期设计对比
实现了基本的设想，只是在可处理的文件种类上存在一些限制
## 项目总结

本项目是在过去几年内几个OSH项目基础上优化发展而来的。

![](pics/evolution.png)




## 致谢

感谢刑凯老师参与了本小组选题、可行性、各个阶段的讨论并提出意见和启发性建议，帮助我们确定了项目的方向。

感谢本次担任助教的学长的帮助。
