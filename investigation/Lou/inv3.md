## 3. Rust 改写 FreeRTOS 的内存管理模块

### 基本信息
项目地址：https://github.com/FreeRTOS/FreeRTOS-Kernel

### 文件结构
```
FreeRTOS-Kernel
├── include/          // 核心头文件
│   ├── portable.h       // 移植层接口定义
│   ├── portmacro.h      // 移植层宏定义（不同架构可能不同）
│   ├── task.h           // 任务管理 API
│   ├── queue.h          // 队列通信 API
│   ├── semphr.h         // 信号量、互斥量 API
│   └── ...              // 其他组件头文件（如时间、内存管理）
├── portable/            // 移植层代码（适配不同处理器架构）
|   ├── MemMang/         // 包含官网上所述的五个示例内存分配器
│   ├── GCC/             // GCC 编译器支持的处理器
│   │   ├── ARM_CM0/     // ARM Cortex-M0 处理器移植代码
│   │   ├── ARM_CM3/     // ARM Cortex-M3 处理器移植代码
│   │   └── ...          // 其他处理器移植目录（如 RISC-V、ESP32 等）
│   └── ...              // 其他编译器（如 IAR、Keil）
├── example/
│   └── ...              //
└── ...                  // 其他辅助文件
```

### 内存分配方式
Free-RTOS提供了如下 5 种堆实现（Heap 1到Heap 5）。以下为FreeRTOS官方文档中对 5 种堆实现的说明。
##### Heap 1
heap_1 的实用性较低，因为 FreeRTOS 已支持静态分配。
heap_1 是所有实现中最简单的。一旦内存被分配，便无法释放。尽管如此，heap_1.c 仍适用于大量嵌入式应用。这是因为许多小型深度嵌入式系统在系统启动时创建所有所需的任务、队列、信号量等对象，并在整个程序生命周期（直到设备关闭或重启）中持续使用这些对象，因此无需删除任何对象。
heap_1 实现的适用场景：
- 如果您的应用从未删除任务、队列、信号量、互斥量等（实际上覆盖了大多数使用 FreeRTOS 的应用）。
- 性能始终确定性（执行时间固定），且不会导致内存碎片化。
- 极其简单，并从静态分配的数组中分配内存，因此通常适用于不允许真实动态内存分配的场景。
##### Heap 2
heap_2 现在被视为遗留方案，因为 heap_4 更为推荐。
heap_2 使用最佳适配算法，与方案 1 不同，允许释放之前已分配的块。但它不会将相邻的空闲块合并为一个大块（合并空闲块的实现请参考 heap_4.c）。
heap_2 的适用场景：
- 即使应用反复删除任务、队列、信号量、互斥量等（但需注意内存碎片化的限制）。
- 如果应用以不可预测的顺序分配或释放队列、任务、信号量、互斥量等，可能导致内存碎片化（尽管这种情况对大多数应用不太可能，但仍需注意）。
- 性能非确定性，但比大多数标准 C 库的 malloc 实现更高效。
heap_2 适用于许多需要动态创建对象的小型实时系统。如需合并空闲块的实现，请参考 heap_4.c。

##### Heap 3
此实现为标准 C 库的 malloc() 和 free() 函数提供了一个简单包装器，通常由编译器提供。包装器仅确保这两个函数是线程安全的。
heap_3 的适用场景：
- 需要链接器设置堆，并依赖编译器库提供 malloc() 和 free() 的实现。
- 性能非确定性。
- 可能显著增加 RTOS 内核的代码体积。

##### Heap 4
此方案使用首次适配算法，并与方案 2 不同，它会合并相邻的空闲块（包含合并算法）。
heap_4 的适用场景：
- 即使应用反复删除任务、队列、信号量、互斥量等。
- 即使分配和释放的内存大小随机，碎片化概率也远低于 heap_2。
- 性能非确定性，但比大多数标准 C 库的 malloc 实现更高效。
heap_4 尤其适合需要直接在应用代码中使用便携层内存分配方案（而非仅通过调用 API 间接使用 pvPortMalloc() 和 vPortFree()）的应用程序。

##### Heap 5
此方案使用与 heap_4 相同的首次适配和内存合并算法，并允许堆跨越多个非相邻（非连续）的内存区域。
heap_5 的 API 功能：
- xPortGetFreeHeapSize() 返回调用时未分配的堆空间总量。
- xPortGetMinimumEverFreeHeapSize() 返回自系统启动以来堆中最小的空闲内存量。
- vPortGetHeapStats() 提供堆状态的详细信息。
pvPortCalloc() 函数与标准库的 calloc 函数签名和功能一致。

##### 关键对比
| **特性**               | **heap_1**       | **heap_2**       | **heap_3**       | **heap_4**       | **heap_5**       |
|------------------------|------------------|------------------|------------------|------------------|------------------|
| **内存释放**           | ❌ 不支持         | ✅ 支持           | ✅ 支持           | ✅ 支持           | ✅ 支持           |
| **合并碎片**           | N/A              | ❌ 不合并         | ❌ 依赖标准库     | ✅ 合并           | ✅ 合并           |
| **非连续内存**         | ❌ 仅单一区域     | ❌ 仅单一区域     | ❌ 仅单一区域     | ❌ 仅单一区域     | ✅ 支持多区域     |
| **确定性**             | ✅ 确定性         | ❌ 非确定性       | ❌ 非确定性       | ❌ 非确定性       | ❌ 非确定性       |
| **适用场景优先级**     | 简单固定系统     | 轻量动态（次选） | 标准库依赖       | 动态复杂系统     | 复杂内存布局     |


