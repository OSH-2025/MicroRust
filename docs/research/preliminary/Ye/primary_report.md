# 项目概述
FreeRTOS是一个开源的实时操作系统,专为嵌入式系统设计,但其默认的内存管理机制较为简单.我们可以使用Rust改写FreeRTOS的内存管理模块,向其中加入,以解决其内存碎片化问题.<br>
# FreeRTOS简介
## 工作原理
FreeRTOS是针对嵌入式系统设计的操作系统,因此在理解FreeRTOS是如何工作前,我们需要首先理解嵌入式系统的工作原理。我们以单片机(最简单的嵌入式系统)为例,通过分析单片机的工作原理,以理解FreeRTOS在其中发挥的作用.<br>
### 单片机
单片机(Microcontroller,简称MCU)是一种集成度非常高的计算机系统，通常包括中央处理单元(CPU),存储器(RAM,ROM),输入输出接口(I/O),定时器,计数器,中断控制器等组成部分,我们可以把单片机理解为一块具有基础输入输出功能的芯片.<br>
单片机的工作过程可以分为以下几个主要步骤:<br>
#### 系统启动
上电:当单片机通电时,首先从存储器中的预定义地址(通常是复位矢量地址)开始执行指令.<br>
复位:通常单片机会先进行复位操作,初始化系统时钟,堆栈,寄存器等重要组件.<br>
加载程序:单片机会从存储器(如Flash)中加载程序代码到CPU中.<br>
#### 程序执行
指令获取(Fetch):CPU根据程序计数器(PC)指向的地址,从内存中读取指令.<br>
指令解码(Decode):将读取到的指令解码,确定需要执行的操作类型.<br>
执行(Execute):执行解码后的操作,如加法运算,数据存储,控制外设等.<br>
#### 任务调度与中断
单片机的执行可以是串行的(即按顺序逐条执行代码),也可以是通过中断机制来实现并行任务执行.<br>
中断:当外部设备或定时器产生中断信号时,CPU会暂停当前的任务,去执行中断服务程序(ISR),处理完中断后再返回原任务.<br>
中断优先级:在有多个中断源时,CPU根据优先级选择要响应的中断.<br>
#### 输入输出操作
单片机的I/O接口与外部设备连接,执行数据读取和写入.通过GPIO,串口,I2C,SPI等接口,单片机能够接收外部输入(如按钮,传感器数据)并进行处理,同时输出控制信号(如驱动电机,控制LED等).<br>
#### 循环执行
通常,单片机会在主程序循环中持续执行任务,直到复位或电源关闭.例如,在一个实时控制系统中,单片机会不断轮询外部输入,处理数据并更新输出.<br>
### FreeRTOS作用
FreeRTOS作为操作系统,本质上就是为了帮助单片机更好的执行任务的程序.在单片机上运行FreeRTOS,我们需要先将其源码编译为二进制的可执行文件,利用单片机的开发程序将其烧录到单片机的内存(如Flash)当中,之后单片机便会逐条读取机器指令并调用根据FreeRTOS的指令有序地执行其他任务.FreeRTOS的烧录与FPGA开发板的烧录类似,区别在于FreeRTOS的烧录是向内存中写入二进制文件,FPGA的烧录是写入RTL结构.<br>
FreeRTOS在单片机上的执行过程涉及从启动到任务调度,任务切换,任务执行等一系列操作,以帮助单片机高效地管理多任务并且实现实时响应.
## 文件结构
我们可以在 https://github.com/FreeRTOS 找到FreeRTOS的源代码.<br>
FreeRTOS仓库是一个包含FreeRTOS内核和多个扩展模块的仓库.这个仓库包含了整个FreeRTOS项目以及与其相关的附加功能,示例代码,文档等资源.我们可以使用该仓库搭建用于FreeRTOS测试的虚拟环境.<br>
FreeRTOS仓库的关键文件结构如下:<br>
```
FreeRTOS
├── FreeRTOS                    # 包含FreeRTOS的核心代码,是我们主要使用的文件.
│   ├── Demo                    # ​包含针对不同硬件平台的演示应用程序,帮助开发者了解如何使用FreeRTOS.
│   ├── Test                    # ​包含对FreeRTOS内核和移植层代码进行测试的文件.
│   └── Source                  # ​包含FreeRTOS内核的源代码文件,指向FreeRTOS-Kernel仓库.
├── FreeRTOS-Plus               # 包含附加功能模块,如FreeRTOS+TCP,MQTT,FAT等.
└── tools                       # 包含FreeRTOS工具和脚本.
```
在我们下一阶段的调研中,需要借助Demo和Test理解如何在QEMU虚拟平台上测试FreeRTOS并学习将FreeRTOS烧录到单片机上的方法.同时,我们需要编写自己的测试文件以彰显我们改写后的内存管理上的优越性.<br>
## 内核文件
FreeRTOS-Kernel仓库是FreeRTOS项目的子仓库,它专注于FreeRTOS的内核代码.该仓库包含FreeRTOS的所有内核文件,也是我们在改写时需要用到的仓库.<br>
FreeRTOS-Kernel仓库的关键文件结构如下:<br>
```
FreeRTOS-Kernel
├── croutine.c,croutine.c,event_groups.c,list.c,queue.c,stream_buffer.c,tasks.c,timers.c
│                               # ​FreeRTOS内核的源代码文件,如任务调度,内存管理,队列,信号量,定时器等核心功能的实现文件.
├── portable                    # 包含与硬件平台相关的移植层代码,确保FreeRTOS能在不同的微控制器和处理器架构上运行.
├── include                     # 包含了FreeRTO 内核的头文件,​它们定义了系统核心所需的宏、数据类型和函数原型.
└── examples                    # 示例代码，帮助初学者掌握FreeRTOS的使用.
```
在我们下一阶段的调研中,我们需要自习阅读上述C语言文件,理解其功能,并以此为基础思考FreeRTOS的内存管理方法.<br>
## 内存管理模块
​FreeRTOS提供了多种内存管理方案,以适应不同的应用需求.实现不同内存管理方案的源代码位于FreeRTOS-Kernel/portable/MemMang目录下,包括以下文件:<br>
### heap_1.c
使用简单的内存分配策略,不支持释放内存块,适用于内存需求固定且无需动态释放的场景.<br>
### heap_2.c
支持内存块的分配和释放,但可能导致内存碎片,适用于对内存碎片容忍度较高的应用.<br>
### heap_3.c
直接封装标准库中的malloc()和free()函数,适用于希望使用标准内存分配接口的场景.<br>
### heap_4.c
​采用最佳匹配算法进行内存分配,并包含合并相邻空闲内存块的功能,适用于需要减少内存碎片的应用.<br>
### hep_5.c
在heap_4.c的基础上增加了内存区域的定义功能,允许在多个内存区域中进行分配,适用于内存分布在不同区域的系统.<br>
# 内存管理
操作系统的内存管理功能负责分配和回收内存资源,确保各个进程在各自的内存空间内独立运行,防止相互干扰.
## FreeRTOS的内存管理
FreeRTOS根据硬件结构的不同,设计了5种不同的内存管理方法,每种内存管理方法都各自拥有不同的优缺点.例如,heap_1.c只能分配内存而不允许释放,减少了内存管理的复杂性,但导致了严重内存浪费;heap_5.c允许将堆内存分布在多个非连续的内存区域,实现了内存块合并算法,但具有初始化复杂和分配时间不确定的问题.<br>
## 问题分析
由于FreeRTOS并非为某一类嵌入式系统量身打造,所以其内存管理算法很难充分利用嵌入式系统的硬件特点,导致相应的资源浪费.与此同时,由于C语言本生在内存安全性上的不足,FreeRTOS可能会产生内存泄漏等问题.因此,我们可以面向常见的单片机架构STM32,使用Rust语言改写FreeRTOS的内存管理.这样,一方面可以利用Rust语言的内存安全性,另一方面也可以将内存管理机制与STM32结构充分结合,提高FreeRTOS在STM32架构上的性能.