#### 基于 Rust 与轻量级 ML 的 FreeRTOS 自适应任务调度器调研报告

---

#### 1. FreeRTOS 任务调度器分析

**1.1 FreeRTOS 调度原则**

FreeRTOS 使用**链表**存储进程，将相同优先级的进程放在同一个链表里。

每隔固定时间，会产生的一个定时器中断，判断当前的最优进程并运行。若有多个优先级最高的进程，则执行时间片轮转策略。

**1.2 FreeRTOS 可配置项**

`configUSE_PREEMPTION` : 设为 1 后高优先级的任务加入后可以抢占，优先执行。

`configUSE_TIME_SLICING`: 设为 1 后最高优先级的若干任务执行时间片轮转策略。

`configIDLE_SHOULD_YIELD`: 设为 1 后空闲进程让步于用户进程（在我们的任务中这一设置无关紧要）

在大部分情况下，这三个可选项都设置为 1。

#### 2. 轻量级机器学习模型可获取的信息

在 FreeRTOS 中集成轻量级 ML 模型进行任务调度时，系统需要为模型提供足够的上下文信息以支持智能决策。以下是 LLM/ML 模型进行调度时可以获取的**关键任务信息**及其技术实现细节：

一、基础任务元信息

这些信息可直接从 FreeRTOS 的 **任务控制块（TCB）** 中提取：
| 信息类型       | 描述                                       | 获取方式                                   |
| -------------- | ------------------------------------------ | ------------------------------------------ |
| **任务句柄**   | 唯一标识任务的指针（`TaskHandle_t`）       | 通过 `xTaskGetHandle("TaskName")` 获取     |
| **静态优先级** | 初始化时设定的优先级（`uxPriority`）       | `uxTaskPriorityGet(task_handle)`           |
| **当前优先级** | 动态调整后的优先级（可能因优先级继承改变） | `uxTaskPriorityGet(task_handle)`           |
| **任务状态**   | 运行/就绪/阻塞/挂起（`eCurrentState`）     | `eTaskGetState(task_handle)`               |
| **堆栈水位线** | 最大堆栈使用量（`usStackHighWaterMark`）   | `uxTaskGetStackHighWaterMark(task_handle)` |

二、运行时动态特征

需通过**钩子函数**或**监控模块**实时采集：单次执行时间， 历史平均/最大执行时间，阻塞时间，资源依赖，触发周期

三、系统级上下文信息

CPU 利用率，内存压力，中断频率，能耗特征

#### 3. 轻量级 ML 调度方案

猜想：可以根据进程原本的优先级和 ML 预测得到的优先级进行加权平均，然后对优先级最高的一些进程进行时间片轮转策略，或当优先级最高的进程与其他进程优先级差距过大时优先执行优先级最高的进程。

#### 4. 难点

1. FreeRTOS 中的进程运行历史信息需要使用特殊的方式进行获取，需要对 FreeRTOS 有一定了解，在 FreeRTOS 运行过程中加入监视函数获取我们所需的信息。
2. 数据集较难获取，若使用 LSTM 等模型，通过进程的历史信息推测它的合适优先度，则需要先查找相关的数据集进行预训练，之后再嵌入系统中。
3. 使用 rust 语言，会难于常见的 python 语言编写大模型。