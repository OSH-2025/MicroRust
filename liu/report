heap1 内存分配方法
heap_1 实现起来就是当需要 RAM 的时候，就从一个大数组(内存堆)中分一小块出来，大数组(内存堆)的容量为 configTOTAL_HEAP_SIZE。

heap_1 特性如下：

1、适用于那些一旦创建好任务、信号量和队列就再也不会删除的应用，实际上大多数的FreeRTOS 应用都是这样的。

2、具有可确定性(执行所花费的时间大多数都是一样的)，而且不会导致内存碎片。

3、代码实现和内存分配过程都非常简单，内存是从一个静态数组中分配到的，也就是适合于那些不需要动态内存分配的应用。

heap2 内存分配方法
heap_2.c 方案与 heap_1.c 方案采用的内存管理算法不一样，它采用一种最佳匹配算法(best fit algorithm)，同样的，内存分配时需要的总的内存堆空间由文件 FreeRTOSConfig.h 中的宏configTOTAL_HEAP_SIZE 配置，单位为字。

heap_2 特性如下：

1、可以用在那些反复的删除任务、队列、信号量、等内核对象且不担心内存碎片的应用程序。

2、如果我们的应用程序中的队列、任务、信号量、 等工作在一个不可预料的顺序，这样子也有可能会导致内存碎片。

3、具有不确定性，但是效率比标准 C 库中的 malloc 函数高得多。

4、不能用于那些内存分配和释放是随机大小的应用程序。

最佳匹配算法：

1、采用最佳匹配算法管理内存，系统会先从内存块空闲链表头开始进行遍历，查找符合用户申请大小的内存块（内存块空闲链表 按内存块的大小升序排列，所以最先返回的的块一定是最符合申请内存大小，这就是的最匹配算法的由来）。

2、当找到内存块的时候， 返回该内存块偏移 heapSTRUCT_SIZE 个字节后的地址， 因为在每块内存块前面预留的节点是用于记录内存块的信息， 用户不需要也不允许操作这部分内存。

首次初始化后的内存堆，xStart 和 xEnd 分别指向空闲内存块链表的首尾。

释放内存块的时候，把需要释放的内存块插入到空闲内存链表中，按照内存块大小升序排序。



heap3 内存分配方法
这种分配算法是对标准的C库的malloc()和free()进行了简单的封装，在内存申请和释放调用C库的标准函数之前，分别增加了调度锁的保护，也就是分配之前先调用vTaskSuspendAll()，然后再调用malloc()函数，最后再调用xTaskResumeAll()。

heap_3 特性如下：

1、需要编译器提供一个内存堆，编译器库要提供 malloc()和 free()函数。比如使用 STM32的话可以通过修改启动文件中的 Heap_Size 来修改内存堆的大小。


2、具有不确定性。

3、可能会增加代码量。

4、不能用于那些内存分配和释放是随机大小的应用程序。

注意：在 heap_3 中 configTOTAL_HEAP_SIZE 是没用的。

具体实现的函数如下：



heap4 内存分配方法
heap_4 提供了一个最优的匹配算法，heap_4 会将内存碎片合并成一个大的可用内存块，它提供了内存块合并算法。
内存堆为 ucHeap[]，大小同样为 configTOTAL_HEAP_SIZE。由文件 FreeRTOSConfig.h 中的宏configTOTAL_HEAP_SIZE 配置，单位为字。


heap_4 特性如下：

1、可以用在那些需要重复创建和删除任务、队列、信号量和互斥信号量等的应用中。

2、不会像 heap_2 那样产生严重的内存碎片，即使分配的内存大小是随机的。
3、具有不确定性，但是远比 C 标准库中的 malloc()和 free()效率高。

最优分配与合并算法：

1、heap_4 也使用链表结构来管理空闲内存块，链表结构体与 heap_2 一样。 heap_4 也定义了两个局部静态变量 xStart 和 pxEnd 来指向链表的首部和尾部，其中 pxEnd 是指向 BlockLink_t 的指针。

首次初始化后的内存堆，xStart 和 xEnd 分别指向空闲内存块链表的首尾。

2、空闲内存块链表中的所有内存，按照内存块的大小从小到大进行排列。

3、当需要分配内存的时候，从 xStart(内存块最小)开始，遍历查找空闲链表来查找大小满足所需要内存的内存块。

4、如果找到了合适大小的内存块，将申请到的内存块从空闲内存链表中移除。

5、如果申请到的内存块大于用户真实所需要的大小，那么要把多余出来的内存重新组合成一个新的可用空闲内存块。

6、将新的空闲内存块，重新按从小到大的顺序插入到空闲内存块链表中。

7、内存释放的时候，遍历空闲内存块链表，找出当前内存块插入点，内存块是按照地址从低到高的顺序链接在一起的。
8、找到插入点以后判断前后空闲内存块，是否可以和要插入的内存块合并，如果可以的话就合并在一起。

9、如果不能合并的话，就将两个空闲内存块用链表连接起来。

释放内存块的时候，把需要释放的内存块插入到空闲内存链表中（插入之前先判断前后空闲内存块是否可以合并），按照内存块大小升序排序。

heap5 内存分配方法
heap_5 使用了 heap_4 相同的分配和合并算法，内存管理实现起来基本相同，但是 heap_5 允许内存堆跨越多个不连续的内存段，比如外挂了SDRAM，可以把SDRAM和内部RAM一起作为内存堆。

heap_5 允许内存堆跨越多个不连续的内存段，这些不连续的内存段就是由结构体 HeapRegion_t 来定义的。

比如：以 STM32F429 为例，现在有三个内存段： CCM、内部 SRAM、外部 SDRAM，起始分别为： 0X10000000、 0X20000000、 0XC0000000，大小分别为： 64KB、192KB、 32MB，那么数组就如下：

HeapRegion_t xHeapRegions[] =
{
    { ( uint8_t * ) 0X10000000UL, 0x10000 }, //CCM 内存，起始地址 0X10000000,大小 64KB
    { ( uint8_t * ) 0X20000000UL, 0x30000 }, //内部SRAM内存，起始地址 0X20000000,大小为 192KB
    { ( uint8_t * ) 0XC0000000UL, 0x2000000},//外部 SDRAM 内存，起始地址 0XC0000000，大小为 32MB
   
    { NULL, 0 } //数组结尾
};
注意：成员顺序必须按照地址的大小，从低到高的顺序排列，而且最后一个成员必须使用 NULL。
